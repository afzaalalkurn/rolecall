/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */ 
/*global jQuery,setTimeout,projekktor,location,setInterval,YT,clearInterval */
var specialeffets = window.specialeffets || {
	classes: {},
	targets: {}
};

(function ($) {
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false */ 
	/*global jQuery,Image */
	
	// jquery 1.9.x fix start 
	var browser,matched;
	
	function uaMatch(ua) {
		ua = ua.toLowerCase();

		var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
			/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
			/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
			/(msie) ([\w.]+)/.exec( ua ) ||
		  ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		  [];

		return {
			browser: match[ 1 ] || "",
			version: match[ 2 ] || "0"
		};
	}
	

	if ( !jQuery.browser ) {
		matched = uaMatch( navigator.userAgent );
		browser = {};

		if ( matched.browser ) {
			browser[ matched.browser ] = true;
			browser.version = matched.version;
		}

		// Chrome is Webkit, but Webkit is also Safari.
		if ( browser.chrome ) {
			browser.webkit = true;
		} else if ( browser.webkit ) {
			browser.safari = true;
		}

		jQuery.browser = browser;
	}
	// fix end
	
	$.specialeffets = $.specialeffets || {version: '1.0.0'};
	
	var ua = navigator.userAgent.toLowerCase();
	var iDev = ua.match(/(iphone|ipod|ipad)/) !== null;
	var android = !iDev && ua.match(/android ([^;]+)/);
	var webkit = ua.match("webkit") !== null;
	if (android) {
		android = android[1].split(/\./);
		android = parseFloat(android.shift() + "." + android.join(""));
	} else {
		android = false;
	}
	var mobile = (iDev || android || ua.match(/(android|blackberry|webOS|opera mobi)/) !== null);

	
	$.specialeffets.browser = {
		iDev: iDev,
		android: android,
		mobile: mobile,
		webkit: webkit
	};
	
	
}(jQuery));

		

// Generated by CoffeeScript 1.6.2
/*
jQuery Waypoints - v2.0.3
Copyright (c) 2011-2013 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/


(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define('waypoints', ['jquery'], function($) {
        return factory($, root);
      });
    } else {
      return factory(root.jQuery, root);
    }
  })(this, function($, window) {
    var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;

    $w = $(window);
    isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
    allWaypoints = {
      horizontal: {},
      vertical: {}
    };
    contextCounter = 1;
    contexts = {};
    contextKey = 'waypoints-context-id';
    resizeEvent = 'resize.waypoints';
    scrollEvent = 'scroll.waypoints';
    waypointCounter = 1;
    waypointKey = 'waypoints-waypoint-ids';
    wp = 'waypoint';
    wps = 'waypoints';
    Context = (function() {
      function Context($element) {
        var _this = this;

        this.$element = $element;
        this.element = $element[0];
        this.didResize = false;
        this.didScroll = false;
        this.id = 'context' + contextCounter++;
        this.oldScroll = {
          x: $element.scrollLeft(),
          y: $element.scrollTop()
        };
        this.waypoints = {
          horizontal: {},
          vertical: {}
        };
        $element.data(contextKey, this.id);
        contexts[this.id] = this;
        $element.bind(scrollEvent, function() {
          var scrollHandler;

          if (!(_this.didScroll || isTouch)) {
            _this.didScroll = true;
            scrollHandler = function() {
              _this.doScroll();
              return _this.didScroll = false;
            };
            return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
          }
        });
        $element.bind(resizeEvent, function() {
          var resizeHandler;

          if (!_this.didResize) {
            _this.didResize = true;
            resizeHandler = function() {
              $[wps]('refresh');
              return _this.didResize = false;
            };
            return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
          }
        });
      }

      Context.prototype.doScroll = function() {
        var axes,
          _this = this;

        axes = {
          horizontal: {
            newScroll: this.$element.scrollLeft(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left'
          },
          vertical: {
            newScroll: this.$element.scrollTop(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up'
          }
        };
        if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
          $[wps]('refresh');
        }
        $.each(axes, function(aKey, axis) {
          var direction, isForward, triggered;

          triggered = [];
          isForward = axis.newScroll > axis.oldScroll;
          direction = isForward ? axis.forward : axis.backward;
          $.each(_this.waypoints[aKey], function(wKey, waypoint) {
            var _ref, _ref1;

            if ((axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll)) {
              return triggered.push(waypoint);
            } else if ((axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll)) {
              return triggered.push(waypoint);
            }
          });
          triggered.sort(function(a, b) {
            return a.offset - b.offset;
          });
          if (!isForward) {
            triggered.reverse();
          }
          return $.each(triggered, function(i, waypoint) {
            if (waypoint.options.continuous || i === triggered.length - 1) {
              return waypoint.trigger([direction]);
            }
          });
        });
        return this.oldScroll = {
          x: axes.horizontal.newScroll,
          y: axes.vertical.newScroll
        };
      };

      Context.prototype.refresh = function() {
        var axes, cOffset, isWin,
          _this = this;

        isWin = $.isWindow(this.element);
        cOffset = this.$element.offset();
        this.doScroll();
        axes = {
          horizontal: {
            contextOffset: isWin ? 0 : cOffset.left,
            contextScroll: isWin ? 0 : this.oldScroll.x,
            contextDimension: this.$element.width(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left',
            offsetProp: 'left'
          },
          vertical: {
            contextOffset: isWin ? 0 : cOffset.top,
            contextScroll: isWin ? 0 : this.oldScroll.y,
            contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up',
            offsetProp: 'top'
          }
        };
        return $.each(axes, function(aKey, axis) {
          return $.each(_this.waypoints[aKey], function(i, waypoint) {
            var adjustment, elementOffset, oldOffset, _ref, _ref1;

            adjustment = waypoint.options.offset;
            oldOffset = waypoint.offset;
            elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp];
            if ($.isFunction(adjustment)) {
              adjustment = adjustment.apply(waypoint.element);
            } else if (typeof adjustment === 'string') {
              adjustment = parseFloat(adjustment);
              if (waypoint.options.offset.indexOf('%') > -1) {
                adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
              }
            }
            waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
            if ((waypoint.options.onlyOnScroll && (oldOffset != null)) || !waypoint.enabled) {
              return;
            }
            if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
              return waypoint.trigger([axis.backward]);
            } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
              return waypoint.trigger([axis.forward]);
            } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
              return waypoint.trigger([axis.forward]);
            }
          });
        });
      };

      Context.prototype.checkEmpty = function() {
        if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
          this.$element.unbind([resizeEvent, scrollEvent].join(' '));
          return delete contexts[this.id];
        }
      };

      return Context;

    })();
    Waypoint = (function() {
      function Waypoint($element, context, options) {
        var idList, _ref;

        options = $.extend({}, $.fn[wp].defaults, options);
        if (options.offset === 'bottom-in-view') {
          options.offset = function() {
            var contextHeight;

            contextHeight = $[wps]('viewportHeight');
            if (!$.isWindow(context.element)) {
              contextHeight = context.$element.height();
            }
            return contextHeight - $(this).outerHeight();
          };
        }
        this.$element = $element;
        this.element = $element[0];
        this.axis = options.horizontal ? 'horizontal' : 'vertical';
        this.callback = options.handler;
        this.context = context;
        this.enabled = options.enabled;
        this.id = 'waypoints' + waypointCounter++;
        this.offset = null;
        this.options = options;
        context.waypoints[this.axis][this.id] = this;
        allWaypoints[this.axis][this.id] = this;
        idList = (_ref = $element.data(waypointKey)) != null ? _ref : [];
        idList.push(this.id);
        $element.data(waypointKey, idList);
      }

      Waypoint.prototype.trigger = function(args) {
        if (!this.enabled) {
          return;
        }
        if (this.callback != null) {
          this.callback.apply(this.element, args);
        }
        if (this.options.triggerOnce) {
          return this.destroy();
        }
      };

      Waypoint.prototype.disable = function() {
        return this.enabled = false;
      };

      Waypoint.prototype.enable = function() {
        this.context.refresh();
        return this.enabled = true;
      };

      Waypoint.prototype.destroy = function() {
        delete allWaypoints[this.axis][this.id];
        delete this.context.waypoints[this.axis][this.id];
        return this.context.checkEmpty();
      };

      Waypoint.getWaypointsByElement = function(element) {
        var all, ids;

        ids = $(element).data(waypointKey);
        if (!ids) {
          return [];
        }
        all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
        return $.map(ids, function(id) {
          return all[id];
        });
      };

      return Waypoint;

    })();
    methods = {
      init: function(f, options) {
        var _ref;

        if (options == null) {
          options = {};
        }
        if ((_ref = options.handler) == null) {
          options.handler = f;
        }
        this.each(function() {
          var $this, context, contextElement, _ref1;

          $this = $(this);
          contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
          if (!$.isWindow(contextElement)) {
            contextElement = $this.closest(contextElement);
          }
          contextElement = $(contextElement);
          context = contexts[contextElement.data(contextKey)];
          if (!context) {
            context = new Context(contextElement);
          }
          return new Waypoint($this, context, options);
        });
        $[wps]('refresh');
        return this;
      },
      disable: function() {
        return methods._invoke(this, 'disable');
      },
      enable: function() {
        return methods._invoke(this, 'enable');
      },
      destroy: function() {
        return methods._invoke(this, 'destroy');
      },
      prev: function(axis, selector) {
        return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
          if (index > 0) {
            return stack.push(waypoints[index - 1]);
          }
        });
      },
      next: function(axis, selector) {
        return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
          if (index < waypoints.length - 1) {
            return stack.push(waypoints[index + 1]);
          }
        });
      },
      _traverse: function(axis, selector, push) {
        var stack, waypoints;

        if (axis == null) {
          axis = 'vertical';
        }
        if (selector == null) {
          selector = window;
        }
        waypoints = jQMethods.aggregate(selector);
        stack = [];
        this.each(function() {
          var index;

          index = $.inArray(this, waypoints[axis]);
          return push(stack, index, waypoints[axis]);
        });
        return this.pushStack(stack);
      },
      _invoke: function($elements, method) {
        $elements.each(function() {
          var waypoints;

          waypoints = Waypoint.getWaypointsByElement(this);
          return $.each(waypoints, function(i, waypoint) {
            waypoint[method]();
            return true;
          });
        });
        return this;
      }
    };
    $.fn[wp] = function() {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (methods[method]) {
        return methods[method].apply(this, args);
      } else if ($.isFunction(method)) {
        return methods.init.apply(this, arguments);
      } else if ($.isPlainObject(method)) {
        return methods.init.apply(this, [null, method]);
      } else if (!method) {
        return $.error("jQuery Waypoints needs a callback function or handler option.");
      } else {
        return $.error("The " + method + " method does not exist in jQuery Waypoints.");
      }
    };
    $.fn[wp].defaults = {
      context: window,
      continuous: true,
      enabled: true,
      horizontal: false,
      offset: 0,
      triggerOnce: false
    };
    jQMethods = {
      refresh: function() {
        return $.each(contexts, function(i, context) {
          return context.refresh();
        });
      },
      viewportHeight: function() {
        var _ref;

        return (_ref = window.innerHeight) != null ? _ref : $w.height();
      },
      aggregate: function(contextSelector) {
        var collection, waypoints, _ref;

        collection = allWaypoints;
        if (contextSelector) {
          collection = (_ref = contexts[$(contextSelector).data(contextKey)]) != null ? _ref.waypoints : void 0;
        }
        if (!collection) {
          return [];
        }
        waypoints = {
          horizontal: [],
          vertical: []
        };
        $.each(waypoints, function(axis, arr) {
          $.each(collection[axis], function(key, waypoint) {
            return arr.push(waypoint);
          });
          arr.sort(function(a, b) {
            return a.offset - b.offset;
          });
          waypoints[axis] = $.map(arr, function(waypoint) {
            return waypoint.element;
          });
          return waypoints[axis] = $.unique(waypoints[axis]);
        });
        return waypoints;
      },
      above: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
          return waypoint.offset <= context.oldScroll.y;
        });
      },
      below: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
          return waypoint.offset > context.oldScroll.y;
        });
      },
      left: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
          return waypoint.offset <= context.oldScroll.x;
        });
      },
      right: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
          return waypoint.offset > context.oldScroll.x;
        });
      },
      enable: function() {
        return jQMethods._invoke('enable');
      },
      disable: function() {
        return jQMethods._invoke('disable');
      },
      destroy: function() {
        return jQMethods._invoke('destroy');
      },
      extendFn: function(methodName, f) {
        return methods[methodName] = f;
      },
      _invoke: function(method) {
        var waypoints;

        waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
        return $.each(waypoints, function(key, waypoint) {
          waypoint[method]();
          return true;
        });
      },
      _filter: function(selector, axis, test) {
        var context, waypoints;

        context = contexts[$(selector).data(contextKey)];
        if (!context) {
          return [];
        }
        waypoints = [];
        $.each(context.waypoints[axis], function(i, waypoint) {
          if (test(context, waypoint)) {
            return waypoints.push(waypoint);
          }
        });
        waypoints.sort(function(a, b) {
          return a.offset - b.offset;
        });
        return $.map(waypoints, function(waypoint) {
          return waypoint.element;
        });
      }
    };
    $[wps] = function() {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (jQMethods[method]) {
        return jQMethods[method].apply(null, args);
      } else {
        return jQMethods.aggregate.call(null, method);
      }
    };
    $[wps].settings = {
      resizeThrottle: 100,
      scrollThrottle: 30
    };
    return $w.load(function() {
      return $[wps]('refresh');
    });
  });

}).call(this);

(function ($) {
	"use strict";
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */
	/*jshint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false, validthis: true */
	/*global jQuery,setTimeout,location,setInterval,YT,clearInterval,clearTimeout,specialeffets */
	
	$.specialeffets = $.specialeffets || {version: '1.0.0'};
	
	$.specialeffets.peLazyLoading = {	
		conf: {
			api: false
		} 
	};
	
	var jwin = $(window);
	var scroller = false;
	var hires = window.devicePixelRatio >= 1.5;
	
	$(function () {
		scroller = $(".scroller > .scroll-content");
		scroller = scroller.length === 0 ? false : scroller;
	});
	
	function PeLazyLoading(target, conf) {
		
		var top, bottom, refresh = true,counter = 0;
		
		function checkIfLoaded(idx,el) {
			if (el.peLoading || el._peLoaded) {
				return;
			}
			
			el = target.eq(el.peIDX);
			
			if (!el.hasClass("pe-lazyloading-forceload")) {
				var y = (refresh || !el.data("pe-lazyload-top")) ?  (el.data("pe-lazyload-forced-top") ? el.data("pe-lazyload-forced-top") : el.offset().top) : el.data("pe-lazyload-top");
				el.data("pe-lazyload-top",y);
			
				var h = (refresh || !el.data("pe-lazyload-height")) ? el.height() : el.data("pe-lazyload-height");
				el.data("pe-lazyload-height",h);
									
				if ((y+h) < top || y > bottom) {
					return;
				}
			}
			
			el.triggerHandler("pe-lazyload-load");
		}
		
		function loaded() {
			var el = target.eq(this.idx);
			el.attr("src",this.src);
			el.addClass("pe-lazyload-loaded").triggerHandler("pe-lazyload-loaded");
			el.fadeTo($.specialeffets.browser.mobile ? 0 : 200,1);
			//el.fadeTo(200,1);
			el[0].peLoaded = true;
			this.src = "";
			counter--;
			//el.addClass("animated fadeIn");
		}

		
		function load() {
			var idx = this.peIDX;
			var el = target.eq(idx);
			this.peLoading = true;
			var img = $("<img />");
			img[0].idx = this.peIDX;
			var src = hires ? el.attr("data-original-hires") : el.attr("data-original");
			// fallback if no hires image is defined
			src = src || el.attr("data-original");
			img.one("load",loaded).attr("src",src);
		}
		
		function init(idx) {
			this.peLoading = false;
			this.peLoaded = false;
			this.peIDX = idx;
			counter++;
			target.eq(idx).css("opacity",0).addClass("pe-lazyload-inited");
		}

		
		function update() {
			if (counter === 0) {
				destroy();
				return true;
			} 
			top = scroller ? scroller.scrollTop() : 0;
			top += jwin.scrollTop();
			bottom = top + (window.innerHeight ? window.innerHeight : jwin.height());
			refresh = true;
			target.each(checkIfLoaded);
			return true;
		}
		
		function destroy() {
			jwin.off("scroll pe-lazyloading-refresh", update);
			if (scroller) {
				scroller.off("scroll",update);
			}
			
			if (target) {
				target.off("pe-lazyload-load");
				target.data("peLazyLoading", null);
				target = undefined;
			}
		}

		
		// init function
		function start() {
			target.each(init);
			target.on("pe-lazyload-load",load);
			$(update);
			jwin.on("scroll pe-lazyloading-refresh", update);
			if (scroller) {
				scroller.on("scroll",update);
			}
		}
		
		$.extend(this, {
			// plublic API
			destroy: destroy
		});
		
		// initialize
		start();
	}
	
	// jQuery plugin implementation
	$.fn.peLazyLoading = function(conf) {
		
		// return existing instance	
		var api = this.data("peLazyLoading");
		
		if (api) { 
			return api; 
		}
		
		conf = $.extend(true, {}, $.specialeffets.peLazyLoading.conf, conf);
		
		//this.each(function() {
			var el = $(this);
			api = new PeLazyLoading(el, conf);
			el.data("peLazyLoading", api); 
		//});
		
		return conf.api ? api: this;		 
	};
	
}(jQuery));

(function ($) {
	"use strict";
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */ 
	/*jshint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false, validthis: true */ 
	/*global jQuery,setTimeout,location,setInterval,YT,clearInterval,clearTimeout,specialeffets,window,JSON */
	
	$.specialeffets = $.specialeffets || {version: '1.0.0'};
	
	$.specialeffets.peLoadMore = {	
		conf: {
			api: false
		} 
	};
	
	var jwin = $(window);
	
	function PeLoadMore(target, conf) {
		var pages = [];
		var active = 0;
		var container,last;
		var buffer;
		var parent;
		var widgets;
		var loading=0;
		
		function loaded(data) {
			
			var pos = target.offset().top;
			if (container.is(parent)) {
				target.detach();
			}
			
			var items = [];
			var isotope = container.closest(".isotope");
			isotope = isotope.length > 0 ? isotope : false;
			var frag = isotope ? false : document.createDocumentFragment();
			
			buffer.find(".pe-load-more-item").each(function () {
				if (frag) {
					frag.appendChild(this);
				}
				items.push(this);
			}); 
			
			items = $(items);
			
			if (isotope) {
				var isoitems = items.filter(".peIsotopeItem");
				isotope.isotope('insert',isoitems).trigger("insert.specialeffets",{items: isoitems,extra:items.not(".peIsotopeItem")});
				setTimeout(function () {
					// just to be safe
					isotope.isotope("resize");
				},100);
			} else {
				container.append(frag);
			}
			
			widgets(items,{});
			
			items.find("img[data-original]:not(img.pe-lazyload-inited)").peLazyLoading();
			
			if (active >= (pages.length-1)) {
				target.hide();
			} else if (container.is(parent)) {
				parent.append(target);
			}
			
			clearTimeout(loading);
			loading = 0;
			hideSpinner();
			target.removeClass('pe-load-more-loading');
		}
		
		function showSpinner() {
			target.addClass('pe-load-more-loading');
		}
		
		function hideSpinner() {
			target.removeClass('pe-load-more-loading');
		}

		function load(e) {
			e.stopImmediatePropagation();
			e.preventDefault();
			if (loading) {
				return false;
			}
			active++;
			var id = container.attr("id");
			var sel = id ? "#"+id : ".pe-load-more-item";
			buffer.load(pages[active]+" %0".format(sel),loaded);
			loading = setTimeout(showSpinner,300);
			return false;
		}

		
		function start() {
			var i,li = target.find("ul > li.pe-is-page");
			
			if (li.length > 1) {
				for (i = 0; i< li.length;i++) {
					var current = li.eq(i);
					if (i === 0 && !current.hasClass("active")) {
						break;
					}
					var href = current.find("a").attr("href");
					if (href) {
						pages.push(href);
					}
				}
				
				if (pages.length > 0) {
					
					if (target.attr("data-all")) {
						var all;
						try {
							all = JSON.parse(target.attr("data-all"));
						} catch (x) {}
						if (all && all.length > pages.length) {
							pages = all;
						}
					}
					
					parent = target.parent();
					var first = parent.find(".pe-load-more-item:first");
					if (first.length === 0) {
						// no items found, bail out
						return;
					}
					last = first.parent().find("> .pe-load-more-item:last");
					container = first.parent();
					
					widgets = typeof specialeffets.controller.widgets === 'function' ? specialeffets.controller.widgets : $.specialeffets.widgets.build;
					buffer = $("<div></div>");
					
					var more = $('<a class="pe-load-more-button" href="#">%0</a>'.format(target.attr('data-msg')));
					more.on("click",load);
					target.addClass('pe-load-more-active').find("ul").replaceWith(more);
					target.prepend('<div class="pe-ajax-portfolio-spinner"><div class="pe-spinner"></div></div>');
				}
			}			
		}

		
		$.extend(this, {
			// public API
			destroy: function() {
				target.data("peLoadMore", null);
				target = undefined;
			}
		});
		
		// initialize
		start();
	}
	
	// jQuery plugin implementation
	$.fn.peLoadMore = function(conf) {
		
		// return existing instance	
		var api = this.data("peLoadMore");
		
		if (api) { 
			return api; 
		}
		
		conf = $.extend(true, {}, $.specialeffets.peLoadMore.conf, conf);
		
		// install the plugin for each entry in jQuery object
		this.each(function() {
			var el = $(this);
			api = new PeLoadMore(el, conf);
			el.data("peLoadMore", api); 
		});
		
		return conf.api ? api: this;		 
	};
	
}(jQuery));

(function ($) {
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false */ 
	/*global jQuery,Image */
	
	
	var a = (new Image()).style,b = 'ransition',c,e,d='nimation',t; 

	t = $.support.csstransitions = 
		(c = 't' + b) in a && c ||
		(c = 'webkitT' + b) in a && c || 
		(c = 'MozT' + b) in a && c || 
		(c = 'OT' + b) in a && c ||
		(c = 'MST' + b) in a && c || 
		false;
	
	$.support.cssanimation = 
		(e = 'a' + d) in a && e ||
		(e = 'webkitA' + d) in a && e || 
		(e = 'MozA' + d) in a && e || 
		(e = 'OA' + d) in a && e ||
		(e = 'MSA' + d) in a && e || 
		false;
	
	$.support.csstransitionsEnd = (t == "MozTransition" && "transitionend") || (t == "OTransition" && (parseInt(jQuery.browser.version,10) >= 12 ? "otransitionend" : "oTransitionEnd")) || (t == "transition" && "transitionend") || (t && t+"End");
	$.support.csstransitionsPrefix = {
		"MozTransition" : "-moz-",
		"webkitTransition" : "-webkit-",
		"OTransition" : "-o-",
		"MSTransition" : "-ms-"
	}[t] || "";
	var an = $.support.cssanimation;
	$.support.cssanimationEnd = an ? (an === "animation" ? "animationend" : an+'End') : false;
		
	//(t == "MozTransition" && "-moz-") || (t == "OTransition" && "-o-") || (t && t+"End");
		
	
}(jQuery));

		

(function ($) {
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */ 
	/*global jQuery,setTimeout,location,setInterval,YT,clearInterval,clearTimeout,specialeffets,Spinner */
	
	var lb;
	
	if (!$.specialeffets || !(lb = $.specialeffets.lightbox)) {
		return;
	}
	
	function Render(id,w,h) {
		
		var img;
		var iw,ih;
		var loading = false;
		var output = false;
		var conf;
		
		function load(el) {
			conf = el;
			lb.signal("locked",id);
			preload(el);
			return this;
		}
		
		function unlock() {
			lb.signal("unlocked",id);
		}

		function resize(nw,nh) {
			w = nw;
			h = nh;
			if (img) {
				var offset = 0;
				if (conf.scale == "fit") {
					offset = 40;
				}
				
				var scaler = $.specialeffets.Geom.getScaler(conf.scale,"center","center",w-offset,h-offset,iw,ih);
				img.transform(
					scaler.ratio,
                    parseInt(scaler.offset.w,10)+offset/2,
					parseInt(scaler.offset.h,10)+offset/2,
					iw,
                    ih,
                    true,
					$.specialeffets.browser.android && $.specialeffets.browser.android < 3 
				);
				
			}
			return this;
		}
		
		function loaded() {
			iw = img[0].naturalWidth || img[0].width || img.width();
			ih = img[0].naturalHeight || img[0].height || img.height();
			lb.signal("loaded",id);
			setTimeout(unlock,500);

		}
		
		function render() {
			if (!output) {
				output = $('<div class="peFlareLightboxRenderImage" />').append(img.addClass(conf.scale));
				img.wrap("<div/>");				
			}
			return output;
		}

		
		function preload(el) {
			loading = true;
			img = $('<img class="singleImage" src="%0"/>'.format(el.resource));
			lb.addToBuffer(img);
			$.specialeffets.preloader.load(img,loaded);
		}
		
		function destroy() {
			img = undefined;
			if (output) {
				output.detach();
				output = undefined;				
			}
			lb.signal("destroy",id);
		}


		$.extend(this, {
			// plublic API
			load: load,
			preload: preload,
			resize: resize,
			render: render,
			isGallery: false,
			destroy: destroy
		});
	}
	
	lb.register(Render,"default");
	
}(jQuery));


(function ($) {
	"use strict";
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */ 
	/*jshint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false, validthis: true */ 
	/*global jQuery,setTimeout,projekktor,location,setInterval,YT,clearInterval,specialeffets,$ */
	$.specialeffets = $.specialeffets || {};

	var items = [];
	var active = [];
	
	function Factory() {
		function add(cond,widget) {
			items.push({
				check:cond,
				widget:widget
			});
		}
		
		function build(target,controller) {
			if (target.data("peWidgets")) {
				return false;
			}
			var applied = false;
			target.data("peWidgets",true);
			var n = items.length;
			var item;
			var elem;
			for (var i=0;i<n;i++) {
				item = items[i];
				elem = item.check(target,controller);
				if (elem) {
					applied = true;
					if (item.widget) {
						active.push(new item.widget(elem));
					}
				}
			}
			return applied;
		}
		
		$.extend(this, {
			"add":add,
			"build":build
		});
	}
	
	$.specialeffets.widgets = new Factory();
}(jQuery));

(function ($) {
	"use strict";
	/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */
	/*jshint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false, validthis: true */
	/*global jQuery,setTimeout,clearTimeout,projekktor,location,setInterval,YT,clearInterval,specialeffets,prettyPrint */
	
	var jwin = $(window),sc;
	var jhtml = $("html");
	var body;
	var container;
	var containerH = 0,h = 0;
	var scroller;
	var filterable = false,isotope = false;
	var layoutSwitcher = false;
	var cells;
	var overs;
	var containerHeightTimer = 0;
	var header,arrows,mobile,background;
	var fullpage;
	var headerY = 0,stickyH = 0;
	var isSticky = false;
	var headlines;
	var sections;
	var sliderBG;
	var stickyMode = "sticky";
	var scrolling = false;
	var changedActive = false;
	var staff;
	var footer,sitebody;
	var openProject = false;
	var stickyFooter = false;
	var overlay;
	var ie8 = ($.browser.msie && $.browser.version < 9);
	var cssA = $.support.cssanimation;
	var topt;
	
	window.peGmapStyle = [
        {
            stylers: [
                { saturation: -100 }
            ]
        },{
            featureType: "road",
            elementType: "geometry",
            stylers: [
                { lightness: 100 },
                { visibility: "simplified" }
            ]
        },{
            featureType: "road",
            elementType: "labels",
            stylers: [
                { visibility: "off" }
            ]
        }
    ];
	
	function imgfilter() {
		return this.href.match(/\.(jpg|jpeg|png|gif)$/i);
	}
	
	specialeffets.classes.Controller = function() {
		
		var w,h,nw,nh;
		var active;
		var nav;
		var useAnimations = false;
		
		function fullPageResize() {
			fullpage.find(".peNeedResize").triggerHandler("resize");
		}

		function resize() {
			nw = jwin.width();
			nh = window.innerHeight ? window.innerHeight: jwin.height();
			
			if (nw === w && nh === h) {
				return;
			}
			
			w = nw;
			h = nh;
			
			// test this
			if (mobile && jwin.scrollTop() > 0) {
				return;
			}
			
			if (fullpage.length > 0) {
				var fh = Math.max(300,h-body.find("section.pe-main-section:first").offset().top);
				var mh = parseInt(fullpage.attr("data-maxheight"),10);
				if (mh > 0) {
					fh = Math.min(fh,mh);
				}
				
				mh = parseInt(fullpage.attr("data-minheight"),10);
				
				if (mh > 0) {
					fh = Math.max(fh,mh);
				}
				
				fullpage.height(fh);
				fullPageResize();
				setTimeout(fullPageResize,500);
				if ($.browser.msie && $.browser.version < 10) {
					setTimeout(fullPageResize,1500);
					setTimeout(fullPageResize,2000);
					setTimeout(fullPageResize,2000);
				}
			}
			
		}
		
		function makeAnimated(e) {
			cells.filter(e.currentTarget).find("div.scalable img").addClass("animated");			
		}
		
		function sticky(e) {
			var wsp = jwin.scrollTop();
			if (sliderBG && !mobile && $.support.csstransforms) {
				sliderBG.transform(1,0,-wsp >> 1);
			}
			body[wsp > 30 ? "addClass" : "removeClass"]("pe-header-scrolled");
			if (stickyFooter && wsp > Math.max(h,1000)) {
				if (!body.hasClass("pe-sticky")) {
					sitebody.css("margin-bottom",footer.outerHeight());
					body.addClass("pe-sticky");
				}
			} else {
				if (body.hasClass('pe-sticky')) {
					//if (wsp < h-footer.outerHeight()) {
						sitebody.css("margin-bottom",0);
						body.removeClass("pe-sticky");
					//}
				}
			}
		}
		
		function widgets(el,controller) {
			el = el || body;
			
			if (el.hasClass("pe-controller-widgets")) {
				return;
			}
			
			el.addClass("pe-controller-widgets");
			
			el.find('.peSlider.peVolo').attr({
				"data-controls-arrows": "edges-buttons",
				"data-controls-bullets": "enabled",
				"data-icon-font": "enabled"
			});
			
			el.find('.carouselBox').attr({
				"data-height": "0,0"
			});
			

			el.find('a.peVideo').attr({
				"data-autoplay": "disabled"
			});
			
			el.find('.peBackground').attr({
				"data-mobile": mobile ? "true" : ""
			});
			
			el.find('.peSlider[data-height]').not('.peGallerySlider').find('> div').addClass("scale");
			
			if (useAnimations) {
				el.find('.pe-animation-maybe').removeClass('pe-animation-maybe').addClass('pe-animation-wants');
			}
			
			if (el === body) {
				resize();
			}
			
			var parallax = $('.pe-main-section.pe-parallax');
			
			if (ie8) {
				el.find('div:last-child').addClass('pe-last-child');
			}
			
			parallax.each(function (idx) {
				var ps = parallax.eq(idx);
				var xpos = "50%";
				if (ps.hasClass("pe-bg-left")) {
					xpos = '0%';
				} else if (ps.hasClass("pe-bg-right")) {
					xpos = '100%';
				}
				if (!mobile && !ie8) {
					ps.parallax(xpos,0.5);
				}
			});
			
			el.find(".post-pagination.pe-load-more").peLoadMore();
			
			$.specialeffets.widgets.build(el,controller);
			
			if (el !== body) {
				var sec = el.closest("section.pe-main-section");
				if (sec.length > 0) {
					sec.data("processed",false);
					animate(sec);
				}
			}
			
		}
		
		function fixHeaderHeight() {
			var logo = header.find("img:first");
			var lh = logo.height() || parseInt(logo.attr("height"),10);
			header.find("header").height(lh).find("> div").height(lh);
			header.find(".pe-menu-main").css("padding-top",lh-37);
			if (!body.hasClass("pe-header-transparent")) {
				body.css("padding-top",header.css("position") === "relative" ? 0 : lh);
			} 
			stickyH = header.height();
			jhtml.data('header-height',stickyH);
			setTimeout(function () {
				stickyH = header.height();
				jhtml.data('header-height',stickyH);
			},100);
		}
		
		function noop(e) {
			e.preventDefault();
			return false;
		}

		
		function makeActive(hash) {
			var url = window.location.href.replace(/#.*/,'') + (hash ? '#'+hash : '');
			var active = header.find("a[href='%0']".format(url));
			
			if (active.length > 0) {
				changedActive = true;
			}
			
			if (changedActive > 0) {
				header.find("li.active").removeClass("active");
				active.parent().addClass("active");
			}	
		}
			
		function sectionHandler(direction) {
			
			if (scrolling) {
				return;
			}
			
			var hash = this.id === 'section-0' ? '' : this.id.replace(/section\-/,'');
			
			/*
			if (!$.browser.msie) {
				window.location.hash = hash;
			}
			*/
			
			makeActive(hash);
		}
		
		function cleanAnimation() {
			var jthis = $(this);
			var cl = jthis.data("removeclass") || "";
			cl += " pe-animation-has pe-animation-wants pe-animation-maybe";
			jthis.removeClass(cl);
			//jthis.removeClass(cl).addClass('pe-animation-maybe pe-animation-wants');
		}

		
		function animate(sec) {
			/*
			if (sec.data("processed")) {
				return;
			}
			*/
			var items = sec.find('.pe-animation-wants').not('.pe-animation-has');
			var delay = 0;
			var incr = 0.3;
			if (items.length > 0) {
				var i,item,cl;
				incr = items.length <= 4 ? 0.3 : 0.1;
				sec.css("overflow","hidden");
				//items.addClass('animated pe-animation-has');
				var clean = [];
				for (i=0;i<items.length;i++) {
					item = items.eq(i);
					if (item.hasClass('pe-animation-has')) {
						continue;
					}
					cl = "animated pe-animation-has "+item.attr('data-animation') || 'fadeIn';
					item.data("removeclass",cl);
					item.one($.support.cssanimationEnd,cleanAnimation);
					item[0].style[cssA+"Delay"] = delay +"s";
					item.addClass(cl);
					delay += incr;
				}

				//items.removeClass('pe-animation-wants');
			}
			sec.data("processed",true);
		}

		
		function animationHandler(direction) {
			var sec = sections.filter(this);
			animate(sec);
		}
		
		function scrollEnd() {
			scrolling = false;
		}

		function hashHandler(e) {
			
			var url = (e && e.currentTarget) ? e.currentTarget.href : window.location.href;
			var hash = url.split(/#/)[1];

			if (hash) {
				var section = sections.filter('[id="section-%0"]'.format(hash));
				if (section.length > 0) {
					makeActive(hash);
					scrolling = true;
					sticky();
					var fixed = header.css("position") == 'fixed';
					scroller.animate({scrollTop: section.offset().top-(fixed ? stickyH : 0)+4},500,scrollEnd);
				}
			}
		}
		
		function staffHandler(e) {
			var member = staff.filter(e.currentTarget);
			
			if (member.data("locked")) {
				return;
			}
			
			var info = member.find(".info-wrap");
			var details = member.find(".details");
			
			
			if (e.type === "mouseenter") {
				member.data("over",true);
				member.css("overflow","hidden").height("auto");
				member.height(member.height());
				info.show();
				details.css("margin-top",-details.height()+41);
				//console.log(-details.height()+24);
			} else {
				if (!member.data("over")) {
					return;
				}
				member.data("locked",true);
				member.data("over",false);
				details.css("margin-top",-20);
				setTimeout(function () {
					info.hide();
					member.height("auto");
					member.data("locked",false);
				},300);
			}
		}
		
		function portfolioLoaded() {
			var project = window.location.hash.match(/\/(.+)/);
			if (project && project[1]) {
				//setTimeout(function () {
					jQuery("a[data-slug='"+project[1]+"']:first").trigger("click");
				//},10);
			} 
		}
		
		function carouselNavigation(e) {
			var carousel = $(e.currentTarget);
			var navigation = carousel.attr("data-show-navigation") != "no";
			try {
				carousel.next()[navigation ? "removeClass" : "addClass"]("pe-block-hidden");
			} catch (x) {
			}
		}
		
		function wrefresh() {
			$.waypoints('refresh');
		}

		
		function start() {
			
			body = $("body");
			scroller = $("html,body");
			mobile = $.specialeffets.browser.mobile;
			
			topt = window.peThemeOptions || {};
			useAnimations = (!mobile && $.support.cssanimation);
			useAnimations = useAnimations && topt.animations == "yes";
			useAnimations = useAnimations && window.peAnimations !== false;
			
			if (!mobile && !($.browser.msie && $.browser.version < 9) && body.is(".pe-sticky-footer.page-template-page_builder-php.pe-page-fullwidth")) {
				footer = body.find("> .site-wrapper > div.footer");
				sitebody = body.find("> div > div.site-body");
				stickyFooter = true;
			}
			
			if (mobile) {
				jhtml.addClass("mobile").removeClass("desktop");
				if ($.specialeffets.browser.android) {
					jhtml.addClass("android");
				} else if ($.specialeffets.browser.iDev) {
					jhtml.addClass("ios");
				}
			} else {
				jhtml.addClass("desktop").removeClass("mobile");
			}
			
			header = $(".site-wrapper .pe-menu-sticky");
			
			fixHeaderHeight();
			
			fullpage = $(".site-wrapper > .site-body > .pe-full-page");
			
			if (!mobile) {
				header.on('click','a[href=#]',noop);
			}
			
			$(".pe-menu-main").each(function () {
				$(this).peMenu();
			});
			
			// pe menu
			/*
			jQuery(function() {
				$(".pe-menu-main").each(function () {
					$(this).peMenu();
				});
				setTimeout(function () {
					$(".project-filter").peMenu();
				},1000);
			});
			*/
			
			$(".pe-full-page .peSlider[data-height]").attr("data-height","300,container,1440");
			$('.header header .sm-icon-wrap a[data-position]').attr("data-position","bottom");
			
			var escapelist = $(".pe-container .pe-escape-container");
			
			escapelist.each(function(idx) {
				var el = escapelist.eq(idx);
				el.closest(".pe-container").before(el);
			});
			
			var splash = $("section.pe-splash-section");

			if (splash.length > 0) {
				sliderBG = splash.find(".peWrap");
				//sliderBG.parent().one("ready.specialeffets",function () {
					var caption = splash.find(" > div.peCaption");
					
					if (caption.length > 0) {
						
						headlines = caption.find(".pe-headlines > div");
						if (headlines.length > 0) {
							var mh = 0,mw = 0;
							headlines.each(function (idx) {
								mw = Math.max(headlines.eq(idx).width(),mw);
								mh = Math.max(headlines.eq(idx).height(),mh);
							});
							caption.find(".pe-headlines").width(mw).height(mh);
						}
						
						var slider = splash.find(".peVolo");
						if (mobile && slider.attr("data-transition") === 'pz' && !window.peForcePanZoom) {
							slider.attr("data-transition","fade");
						}
						slider.find(".peCaption").remove();
						slider.find(".peWrap > div:first").prepend(caption);
						
						var ah = 0;
						setInterval(function () {
							ah = (ah + 1) % headlines.length;
							headlines.removeClass("pe-active").eq(ah).addClass("pe-active");
							
						},4000);
					}
				//}); 
			}
			
			if (!mobile) {
				staff = $(".pe-view-layout-class-staff .staff-item");
				staff.on("mouseenter mouseleave",staffHandler);
				
			}
			
			var bgyt = $("#pe-bg-video");
			
			if (bgyt.length > 0) {
				if (!$.fn.mb_YTPlayer || mobile || ie8 || window.peBgVideo === false) {
					if (bgyt.attr("data-fallback")) {
						bgyt.css({
							"background-image" : 'url(%0)'.format(bgyt.attr("data-fallback"))
						}).addClass("pe-active");
					}
				} else {
					var def;
					try {
						def = eval('({%0})'.format(bgyt.attr("data-settings")));
					} catch (x) {
						console.log("error parsing video data-settings");
						def = {containment:'body',autoPlay:true, mute:true, startAt:0, opacity:1, showControls:0};
					}
					var videos = [];
					var i = 0,video;
					while ((video = bgyt.attr('data-video%0'.format(i++)))) {
						videos.push(jQuery.extend({videoURL:video},def));
					}
					bgyt.YTPlaylist(videos, false);
				}
				$("#pe-bg-video-overlay").addClass("pe-active");
			}
			
			$(".pe-ajax-portfolio:last").one("ajaxloaded.specialeffets",portfolioLoaded);
			$(body).on("pe-carousel-navigation",".carouselBox",carouselNavigation);
			
			widgets(body,{});
			
			$("img[data-original]:not(img.pe-lazyload-inited)").peLazyLoading();
			
			if (mobile) {
				setTimeout(function () {
					//alert("ok");
					jwin.triggerHandler("pe-lazyloading-refresh");
				},100);
			} else {
				cells = $(".peIsotopeGrid .peIsotopeItem");
				cells.one("mouseenter",makeAnimated);
			}
			
			jwin.resize(resize);
			jwin.on("load",resize);
			jwin.on("scroll",sticky);
			
			sections = $('section.pe-main-section');
			var refresh = false;
			
			if (sections.length > 1) {
				refresh = true;
				sections.filter(".pe-splash-section").waypoint({handler: sectionHandler,offset: -100});
				sections.not(".pe-splash-section").waypoint({handler: sectionHandler,offset: 100});
			}
			
			if (useAnimations && sections.length > 0) {
				refresh = true;
				var wh = window.innerHeight ? window.innerHeight: jwin.height();
				sections.not(".pe-splash-section").waypoint({handler: animationHandler,offset: wh-(window.peAnimationOffset ? window.peAnimationOffset : 200 )});
			}
			
			if (refresh) {
				setTimeout(wrefresh,500);
				setInterval(wrefresh,1000);
			}
			
			//jwin.on("hashchange",hashHandler);
			
			body.on("click","a[href]",hashHandler);
			hashHandler();
			//makeActive();
			resize();
			overlay = body.find("> .site-loader");
			if (overlay.length > 0) {
				//jwin.one("load",function () {
				setTimeout(function() {
					overlay.addClass("pe-disabled");
					setTimeout(function () {
						overlay.css("visibility","hidden");
					},500);
					jwin.on("beforeunload",function (e) {
						overlay.css("visibility","visible").removeClass("pe-disabled");
					});
				},500);	
				//});
			}
			
			
			
		}
		
		$.extend(this, {
			// public API
			widgets: widgets,
			start: start
		});
		
	};
	
}(jQuery));

/*jslint undef: false, browser: true, devel: false, eqeqeq: false, bitwise: false, white: false, plusplus: false, regexp: false, nomen: false */ 
/*global jQuery,setTimeout,projekktor,location,setInterval,YT,clearInterval,specialeffets,influx_load,yepnope */
jQuery(function($){
	
	if (window.peFallBackPlayer) {
		$.specialeffets.video.fallBackPlayer = decodeURIComponent(window.peFallBackPlayer.url);
	}
	
	specialeffets.controller = new specialeffets.classes.Controller();		
	specialeffets.controller.start();
});